STD29006 – Sistemas Distribuídos 12/03/2020
Laboratório 2: RPC e RMI
Professor: Emerson Ribeiro de Mello http://docente.ifsc.edu.br/mello/std
i
Nota:
O objetivo deste laboratório: Apresentar como desenvolver aplicações cliente e servidor com
ONC RPC e com Java RMI.
1 Aplicação ONC RPC
Para compilar e executar essa aplicação é necessário ter o ONC RPC instalado.
1 sudo apt-get install rpcbind
1.1 Interface em XDR com duas operações: soma e subtração
Baixe o código fonte clicando aqui.
#define PROGRAM_NUMBER 0x20001234
#define VERSION_NUMBER 1
/*estrutura com os parametros*/
struct operandos{
int a;
int b;
};
/*interface com os procedimentos ofertados pelo servidor*/
program SOMASUB_PROG{
version SOMASUB_VERSION{
int SOMA (operandos) = 1;
int SUB (operandos) = 2;
} = VERSION_NUMBER;
} = PROGRAM_NUMBER;
Para compilar a interface:
16 rpcgen interface.x
17 (ou rpcgen -a -C interface.x para gerar esqueletos para cliente e servidor)
1.2 Código do servidor RPC: servidor.c
Baixe o código fonte clicando aqui.
#include <stdio.h>
#include "interface.h"
/* implementacao da funcao soma */
int * soma_1_svc (operandos *argp, struct svc_req *rqstp){
static int result;
printf ("Recebi chamado: soma %d %d\n", argp->a, argp->b);
IFSC – CAMPUS SÃO JOSÉ 1
result = argp->a + argp->b;
return (&result);
}
/* implementacao da funcao sub */
int * sub_1_svc (operandos *argp, struct svc_req *rqstp){
static int result;
printf ("Recebi chamado: sub %d %d\n", argp->a, argp->b);
result = argp->a - argp->b;
return (&result);
}
Para compilar o código do servidor:
38 gcc servidor.c interface_svc.c interface_xdr.c -o servidor -lnsl
1.3 Código do cliente RPC: cliente.c
Baixe o código fonte clicando aqui.
#include <stdio.h>
#include "interface.h"
/* funcao que invoca a RPC soma_1 */
int soma (CLIENT *clnt, int a, int b){
operandos ops;
int *resultado;
ops.a = a;
ops.b = b;
/* chama a funcao remota */
resultado = soma_1 (&ops,clnt);
if (resultado == NULL){
printf ("Problemas ao chamar a funcao remota\n");
exit (1);
}
return (*resultado);
}
/* funcao que invoca a RPC sub_1 */
int sub (CLIENT *clnt, int x, int y){
operandos ops;
int *resultado;
ops.a = x;
ops.b = y;
/* chama a funcao remota */
resultado = sub_1 (&ops,clnt);
if (resultado == NULL){
printf ("Problemas ao chamar a funcao remota\n");
exit (1);
}
return (*resultado);
}
int main( int argc, char *argv[]){
CLIENT *clnt;
int x,y;
/* verifica se o cliente foi chamado corretamente */
if (argc!=4){
fprintf (stderr,"Sintaxe: %s hostname operando1 operando2\n",argv[0]);
exit (1);
}
/* cria uma struct CLIENT que referencia uma interface RPC */
IFSC – CAMPUS SÃO JOSÉ 2
clnt = clnt_create (argv[1], SOMASUB_PROG, SOMASUB_VERSION, "udp");
/* verifica se a referencia foi criada */
if (clnt == (CLIENT *) NULL){
clnt_pcreateerror (argv[1]);
exit(1);
}
/* converte os argumentos de linha de comando para inteiro*/
x = atoi (argv[2]);
y = atoi (argv[3]);
/* executa os procedimentos remotos */
printf ("%d + %d = %d\n", x, y, soma (clnt,x,y));
printf ("%d - %d = %d\n", x, y, sub (clnt,x,y));
return (0);
}
Para compilar o código do cliente:
96 gcc cliente.c interface_clnt.c interface_xdr.c -o cliente -lnsl
2 Java RMI
2.1 Interface do objeto distribuído
A interface ContadorDistribuido.java possui dois métodos: void incrementar() e int
obterValorAtual(). Esse arquivo deve ser disponibilizado para os desenvolvedores do aplicativo Servidor e do aplicativo Cliente.
package std29006;
import java.rmi.Remote;
import java.rmi.RemoteException;
/**
* Interface que deve ser compartilhada por servidor e clientes
*/
public interface ContadorDistribuido extends Remote{
public void incrementa() throws RemoteException;
public int obtemValorAtual() throws RemoteException;
}
2.2 Desenvolvendo o aplicativo servidor
A classe Contador.java implementará a interface ContadorDistribuido.java.
package std29006.server;
import std29006.ContadorDistribuido;
/**
* Classe que implementa a interface do objeto distribu´ıdo
*/
public class Contador implements ContadorDistribuido{
private int valor = 0;
@Override
public void incrementa() throws RemoteException {
this.valor++;
}
@Override
public int obtemValorAtual() throws RemoteException {
return this.valor;
}
}
IFSC – CAMPUS SÃO JOSÉ 3
A classe Servidor.java é responsável por instanciar um objeto da classe Contador, subir um
serviço de nomes (rmiregistry) e registrar a instância da classe Contador no serviço de nomes.
package std29006.server;
import std29006.ContadorDistribuido;
import java.rmi.AlreadyBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.logging.Level;
import java.util.logging.Logger;
/**
* Classe respons´avel por criar uma inst^ancia do objeto Contador e registr´a-la
* em um servi¸co de registro de objetos distribu´ıdos
*/
public class Servidor {
// Constantes que indicam onde est´a sendo executado o servi¸co de registro,
// qual porta e qual o nome do objeto distribu´ıdo
private static String nomeServidor = "127.0.0.1";
private static int porta = 12345;
private static final String NOMEOBJDIST = "MeuContador";
public static void main(String args[]){
try {
// recebendo nome do servidor por argumento de linha de comando
if (args[0] != null){
nomeServidor = args[0]
}
// recebendo porta do rmiregistry por argumento de linha de comando
if (args[1] != null){
porta = Integer.parseInt(args[1]);
}
// Criando
Contador c = new Contador();
// Definindo o hostname do servidor
System.setProperty("java.rmi.server.hostname", nomeServidor);
ContadorDistribuido stub = (ContadorDistribuido)
UnicastRemoteObject.exportObject(c, 0);
// Criando servi¸co de registro
Registry registro = LocateRegistry.createRegistry(porta);
// Registrando objeto distribu´ıdo
registro.bind(NOMEOBJDIST, stub);
System.out.println("Servidor pronto!\n");
System.out.println("Pressione CTRL + C para encerrar...");
} catch (RemoteException | AlreadyBoundException ex) {
Logger.getLogger(Servidor.class.getName()).log(Level.SEVERE, null, ex);
}
}
}
IFSC – CAMPUS SÃO JOSÉ 4
2.3 Desenvolvendo aplicativo Cliente
A classe Cliente.java é responsável por invocar os métodos remotos do Servidor. Ao executar o cliente é necessário informar o nome (ou IP) e porta da máquina onde o rmiregistry está
sendo executado.
package std29006.client;
import std29006.ContadorDistribuido;
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.util.logging.Level;
import java.util.logging.Logger;
/**
* Cliente de uma aplica¸c~ao Java RMI
*/
public class Cliente {
private static String nomeServidor = "127.0.0.1";
private static int porta = 12345;
private static final String NOMEOBJDIST = "MeuContador";
public static void main(String args[]) {
try {
if (args[0] != null){
nomeServidor = args[0];
}
if (args[1] != null){
porta = Integer.parseInt(args[1]);
}
System.out.println("Conectando no servidor "+ nomeServidor);
// Obtendo refer^encia do servi¸co de registro
Registry registro = LocateRegistry.getRegistry(nomeServidor, porta);
// Procurando pelo objeto distribu´ıdo registrado previamente com o NOMEOBJDIST
ContadorDistribuido stub = (ContadorDistribuido) registro.lookup(NOMEOBJDIST);
// Invocando m´etodos do objeto distribu´ıdo
System.out.println("Valor atual: " + stub.obtemValorAtual());
System.out.println("Solicitando ao servidor para incrementar o contador");
stub.incrementa();
System.out.println("Valor atual: " + stub.obtemValorAtual());
System.out.println("Fim da execu¸c~ao do cliente!");
} catch (RemoteException | NotBoundException ex) {
Logger.getLogger(Cliente.class.getName()).log(Level.SEVERE, null, ex);
}
}
}
2.4 Compilando e executando o servidor
No servidor é necessário criar o arquivo (java.policy) com a seguinte política de segurança:
grant{
permission java.security.AllPermission;
}
javac std29006/server/Servidor.java
java -Djava.security.policy=java.policy std29006.server.Servidor XXX.XXX.XXX.XXX 12345
IFSC – CAMPUS SÃO JOSÉ 5
2.5 Compilando e executando o cliente
javac std29006/client/Cliente.java
java std29006.client.Cliente XXX.XXX.XXX.XXX 12345
2.6 Organização do projeto nas máquinas Cliente e Servidor
• Máquina cliente
.
`-- std29006
|-- client
| `-- Cliente.java
`-- ContadorDistribuido.java
• Máquina servidor
.
`-- std29006
|-- ContadorDistribuido.java
`-- server
|-- Contador.java
`-- Servidor.java
3 Exercício: Sistema de inventário de ativos de WiFi
Desenvolva uma aplicativo cliente / servidor baseado em RMI para fazer o inventário de pontos de acesso (Access Point – AP) WiFi. Ao cadastrar um AP é necessário informar um nome,
MAC address, frequências que opera (2.4Ghz, 5Ghz ou ambas) e em qual sala do prédio esse
AP está afixado (por exemplo: lab. redes II). O aplicativo servidor é o responsável por manter
esse inventário em memória e o aplicativo cliente é responsável por fazer requisições ao servidor para cadastrar, remover ou listar pontos de acesso. Ao listar os pontos de acesso o cliente
poderá indicar critérios de seleção. Exemplos:
• Cadastrar um novo AP na sala lab SiDi e que opere em ambas as frequências
java ClienteInventario <endere¸co servidor> add "AP1" "mac:abcdef" "freq:2.4:5" "Lab SiDi"
• Listar todos os APs
java ClienteInventario <endere¸co servidor> list
• Listar todos os APs que operam com a frequência de 5Ghz.
java ClienteInventario <endere¸co servidor> list freq:5
• Remover AP com o identificador AP2
java ClienteInventario <endere¸co servidor> del AP2
i
Nota:
Garantam que todos os aplicativos clientes poderão se comunicar com qualquer aplicativo
servidor desenvolvido por qualquer aluno da turma.
IFSC – CAMPUS SÃO JOSÉ 6
